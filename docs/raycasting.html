<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="container">
<div class="column" id="column1">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="index.html">Home</a></li>
<li id="menu-top-level-item"><a href="raycasting.html">Cast the Ray</a></li>
<li id="menu-top-level-item"><a href="struct-metadata.html">Struct Metadata</a></li>
</ul>
</div>
<div class="column" id="column2">
<h1 id="Cast-the-Ray">Cast the Ray</h1>
<p>While working on my game, I encountered a common issue. How to select entities in the game world by clicking on them, and how to handle entity collisions. When you use any modern game engine, those things would most likely be fully covered by a physics engine or simply part of the engine API. But I don’t have such a thing.</p>
<p>Originally, I didn’t want to spend too much time on this; there is a lot more to cover while creating a game from scratch. The laziest approach is relying on AI, just letting it implement all collision-related procedures, and copy-paste them with some possible adjustments. This kinda works until it doesn’t, and you find yourself staring at code you actually don’t understand. So I decided to step back and try to dedicate more time to this.</p>
<p>The usual solution would be to cast a ray from the player/camera position into the world and use the hit information to select an entity or handle collisions, if any.</p>
<p>In this blog post, I’ll try to explain in detail how to implement simple raycasting, focusing on the practical side, and do a little bit of math in a way even I’m able to understand (I’m not really into math).</p>
<h2 id="What-is-raycast?">What is raycast?</h2>
<p>You can think about it as a laser beam pointing from a point in the game world in some direction, and we somehow want to detect if this beam hits something in the world, and get some information about the hit point. So let's define our raycast as origin point <code>O</code> and normalized direction vector <code>D</code>.</p>
<p><img src="raycasting/raycast.svg" alt=""></p>
<p>Such a definition of raycast on its own is not enough. We also need to control where we are on this oriented line. Since the direction vector is normalized, we can just multiply it by a scalar, usually called <code>t</code> to control how far from the origin we are. Note that when the direction vector is normalized, <code>t</code> is actually in world units. So to get, for example, point <code>P</code> two units far from the origin in the direction <code>D</code> we do <code>P=O+2D</code>.</p>
<p>This brings us to the general definition of our raycast:</p>
<p><img src="raycasting/formula.svg" alt=""></p>
<p>From a practical side, it's good to define some bounds for the <code>t</code> value. We probably don't want it to be negative, and we usually don't want to include hits too far from the origin. To have full control over these properties, we can define <code>t_min</code> and <code>t_max</code> values.</p>
<p>So the full definition of the raycast in code looks like this:</p>

<pre><code>Ray :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    origin: v3;
    direction: v3;
    t_min: f32;
    t_max: f32;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Hit-Point">Hit Point</h2>
<p>By hit point, we mean the exact intersection point of our raycast and the object in the scene. In other words, we're trying to find one point lying on the raycast and geometry at the same time. Based on the raycast definition, we're looking for <code>t</code> value of such a point.</p>
<p>To store collected information about the hit point, I use the following structure:</p>

<pre><code>Hit :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    id: u32;
    t:  f32;
    n:  v3;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Where <code>id</code> is a unique identifier of the hit object, <code>t</code> value and hit surface normal <code>n</code>. You can include any other information needed.</p>
<p>As you can imagine, calculating the intersection of our ray with a full model triangle geometry might be too complex to start with, so let's take a look at the simplest case possible first.</p>
<h2 id="Ray-vs-Plane">Ray vs Plane</h2>
<p>Probably the simplest case we can implement is checking if our raycast intersects a plane. Crucial construct used in the following calculations is <em>dot product</em>, I'll not go into details explaining it here, you can watch <a href="https://www.youtube.com/live/fjOdtSu4Lm4?si=qgWHYcV_Co30lcU0">video</a> from Freya Holmér containing a very detailed explanation.</p>
<p>Let's just highlight some algebra-like properties of the dot product (<code>⋅</code>):</p>
<ul>
<li>Commutative: <code>A⋅B=B⋅A</code></li>
<li>Distributive: <code>A⋅(B+C)=A⋅B+A⋅C</code></li>
<li>Scalar multiplication: <code>(sA)⋅B=s(A⋅B)</code></li>
</ul>
<p>Our plane will be defined by the origin point in space <code>P0</code> and a normal vector <code>N</code> like this:</p>
<p><img src="raycasting/plane.svg" alt=""></p>
<p>So in mathematical terms, where <code>P</code> is any point lying on the plane, we can write this:</p>
<p><img src="raycasting/plane-formula.svg" alt=""></p>
<p>Note that the dot product is 0 in case its input vectors are perpendicular.</p>
<p>When we're looking for the intersection point, we can just inject our previous raycast definition into the plane definition and solve it for <code>t</code>. Note that I use capital letters for vectors and small letters for scalars (float numbers) here.</p>
<p><img src="raycasting/inject-plane-formula.svg" alt=""></p>
<p>Now we can calculate the value of <code>t</code>, telling us how far from the raycast origin the ray intersects the plane. Thus, to calculate the hit point position, we can use the raycast definition with our <code>t</code> value.</p>
<p><img src="raycasting/formula.svg" alt=""></p>
<p>As you may have noticed, we divide by <code>N⋅D</code>, but the denominator cannot be 0. As already mentioned, the dot product is zero when the input vectors are perpendicular; this means our raycast is perfectly parallel to our plane and thus never hits it. We have to check this explicitly in the code.</p>
<p>The final ray vs plane procedure might be implemented like this:</p>

<pre><code>ray_vs_plane :: <span class="syntax-keyword">fn</span> (ray: Ray, plane: Plane, hit: *Hit = null) bool <span class="syntax-keyword">{</span>
    o     :: ray.origin;
    d     :: ray.direction;
    p0, n :: get_plane(plane);

    denom :: dot(d, n);
    <span class="syntax-keyword">if</span> math.compare(denom, 0.f, EPS) <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;

    t :: dot(n, sub(p0, o)) / denom;
    <span class="syntax-keyword">if</span> t &gt;= ray.t_min && t &lt;= ray.t_max <span class="syntax-keyword">{</span>
        <span class="syntax-keyword">if</span> hit <span class="syntax-keyword">{</span>
            hit.t = t;
            hit.n = n;
        <span class="syntax-keyword">}</span>
        <span class="syntax-keyword">return</span> true;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> false;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Ray-vs-Sphere">Ray vs Sphere</h2>
<p>Similarly, we can find the raycast collision point with a sphere. The whole equation is a bit more complex; however, it applies the same principles. Our sphere is defined as a center point <code>P0</code> and a radius <code>r</code>.</p>
<p><img src="raycasting/sphere11.svg" alt=""></p>
<p>For any point <code>P</code> we can define a sphere as follows:</p>
<p><img src="raycasting/sphere.svg" alt=""></p>
<p>Note that <code>||</code> here represents <em>vector magnitude</em>. There is also one simple trick I didn't know, we can represent the squared magnitude of any vector as <em>dot product</em> with itself. Thus, we can do the following to make our computation a bit "easier".</p>
<p><img src="raycasting/sphere2.svg" alt=""></p>
<p>Now we can replace point <code>P</code> with the raycast formula:</p>
<p><img src="raycasting/sphere3.svg" alt=""></p>
<p>In the next steps, we solve this equation for <code>t</code>. Since it's easy for me to mess up, I do some substitutions here and there to reduce the risk (<code>L</code> and <code>M</code> variables).</p>
<p><img src="raycasting/sphere4.svg" alt=""></p>
<p>Finally, some rearrangement:</p>
<p><img src="raycasting/sphere5.svg" alt=""></p>
<p>At this point, it's getting quite obvious that we're dealing with a quadratic equation:</p>
<p><img src="raycasting/sphere6.svg" alt=""></p>
<p>We can write down all coefficients:</p>
<p><img src="raycasting/sphere7.svg" alt=""></p>
<p>To solve <code>t</code> we can use the quadratic formula (google it):</p>
<p><img src="raycasting/sphere8.svg" alt=""></p>
<p>Let's take a look at the <em>determinant</em> first:</p>
<p><img src="raycasting/sphere9.svg" alt=""></p>
<p>In case the <em>determinant</em> is negative, we cannot calculate its square root. Meaning the raycast completely missed the sphere.</p>
<p>In case the <em>determinant</em> value is zero, the quadratic equation has only one solution, meaning the raycast just touched the sphere at a single point.</p>
<p>Otherwise, we have to pick <code>t</code> greater than <code>t_min</code> and one closer to the raycast origin.</p>
<p><img src="raycasting/sphere10.svg" alt=""></p>
<p>The final ray vs sphere procedure might be implemented like this:</p>

<pre><code>ray_vs_sphere :: <span class="syntax-keyword">fn</span> (ray: Ray, sphere_center: v3, sphere_radius: f32, hit: *Hit = null) bool <span class="syntax-keyword">{</span>
    o  :: ray.origin;
    d  :: ray.direction;
    p0 :: sphere_center;
    r  :: sphere_radius;

    op :: sub(o, p0);
    a :: dot(d, d);
    b :: 2.f*dot(d, op);
    c :: dot(op, op)-r*r;

    det :: b*b-4.f*a*c;
    <span class="syntax-comment">// Quadratic equation does not have any solution, ray misses the sphere.</span>
    <span class="syntax-keyword">if</span> det &lt; 0.f <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;

    a2 :: 2.f*a;
    detsqrt :: math.sqrt(det);
    t1 :: (-b + detsqrt)/a2;
    t2 :: (-b - detsqrt)/a2;

    <span class="syntax-comment">// Possible cases:</span>
    <span class="syntax-comment">// t1 &lt; t_min && t2 &lt; t_min: Both hits are behind the raycast origin.</span>
    <span class="syntax-comment">// t1 &lt; t_min && t2 &gt; t_min: We're inside the sphere.</span>
    <span class="syntax-comment">// t1 &gt; t_min && t2 &gt; t_min: We're hitting the sphere and we should pick closest point.</span>

    t := t1;
    <span class="syntax-keyword">if</span> t &lt; ray.t_min <span class="syntax-keyword">{</span>
        t = t2;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">if</span> t &gt;= ray.t_min && t &lt;= ray.t_max <span class="syntax-keyword">{</span>
        p :: add(o, mul(d, t));
        <span class="syntax-keyword">if</span> hit <span class="syntax-keyword">{</span>
            hit.t = t;
            hit.n = div(sub(p, p0), r);
        <span class="syntax-keyword">}</span>
        <span class="syntax-keyword">return</span> true;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> false;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Ray-vs-Axis-Aligned-Bounding-Box">Ray vs Axis Aligned Bounding Box</h2>
<p>The Axis-Aligned Bounding Box (AABB) is a common simplification for 3D objects in my game. In some cases, we don't need an exact object representation (triangle mesh), and just a simple bounding box is enough. By bounding box, we mean a box encapsulating the whole object defined as <em>minimum</em> and <em>maximum</em> vectors. Axis-aligned means the box is not rotated (defined in the object's local space).</p>
<p><img src="raycasting/aabb.svg" alt=""></p>
<p>While finding the intersection point with raycast, we can, in fact, reuse knowledge we already have. Every AABB consists of six planes (two planes on each axis).  And we already know how to calculate the <code>t</code> value for the ray-plane intersection.</p>
<p><img src="raycasting/aabb-plane.svg" alt=""></p>
<p>So the goal here is to calculate <code>t</code> for each plane of the bounding box and pick the closest one to the ray origin. There is one simplification we can do, since our bounding box is axis-aligned, the normals of all planes are also aligned (parallel) to the coordinate system axes. For example, the normal of the left face is parallel to the <em>x</em> axis (x = 1, y = 0, z = 0). So we can simplify the equation by taking into account only non-zero normal components. For the left plane of the bounding box, we can write:</p>
<p><img src="raycasting/aabb-plane-x.svg" alt=""></p>
<p>Notice that now we're dealing with scalars, and the equation can be simplified even more:</p>
<p><img src="raycasting/aabb-plane-x2.svg" alt=""></p>
<p>Now we can calculate <code>t</code> values for one pair of planes on the <code>x</code> axis (left and right plane) as follows:</p>
<p><img src="raycasting/aabb-plane-x3.svg" alt=""></p>
<p>Where a smaller <code>t</code> value is the entry point where the ray enters the box, and a larger <code>t</code> value is the exit point.
We can now calculate <code>t</code> values for all remaining axes (bottom, top, front, back). Notice, we've separated the intersection test into three independent tests: one for each axis. To get the final result, we need to calculate the intersection of all three <code>t</code> intervals. Plotting these intervals might help us to understand what's going on:</p>
<p><img src="raycasting/aabb-min-max.svg" alt=""></p>
<p>Values <code>t_min</code> and <code>t_max</code> are resulting <code>t</code> values we can use to finalise the intersection test.</p>
<p>When <code>t_min &gt; t_max</code>, we have no overlap in these intervals, meaning the ray misses the box. When <code>t_max &lt; 0</code>, our intersection is "behind" the raycast origin. Otherwise, we take <code>t_min</code> as the result value.</p>
<p>Example of possible implementation:</p>

<pre><code>ray_vs_aabb :: <span class="syntax-keyword">fn</span> (ray: Ray, aabb_min: v3, aabb_max: v3, hit: *Hit = null) bool <span class="syntax-keyword">{</span>
    o  :: ray.origin;
    d  :: ray.direction;

    <span class="syntax-comment">// Inverse direction, so we multiply later instead of dividing.</span>
    di :: v3.<span class="syntax-keyword">{</span> 1.f / d.x, 1.f / d.y, 1.f / d.z, <span class="syntax-keyword">}</span>;

    t_left   :: (aabb_min.x - o.x) * di.x;
    t_right  :: (aabb_max.x - o.x) * di.x;
    t_bottom :: (aabb_min.y - o.y) * di.y;
    t_top    :: (aabb_max.y - o.y) * di.y;
    t_front  :: (aabb_min.z - o.z) * di.z;
    t_back   :: (aabb_max.z - o.z) * di.z;

    <span class="syntax-keyword">using</span> math;
    t_min_x :: min(t_left,   t_right);
    t_max_x :: max(t_left,   t_right);
    t_min_y :: min(t_bottom, t_top);
    t_max_y :: max(t_bottom, t_top);
    t_min_z :: min(t_front,  t_back);
    t_max_z :: max(t_front,  t_back);

    t_min :: max(max(t_min_x, t_min_y), t_min_z);
    t_max :: min(min(t_max_x, t_max_y), t_max_z);

    <span class="syntax-comment">// if t_min &gt; t_max, ray doesn't intersect AABB.</span>
    <span class="syntax-keyword">if</span> t_min &gt; t_max <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;
    <span class="syntax-comment">// if t_max &lt; 0, ray (line) is intersecting AABB, but the whole AABB is behind us.</span>
    <span class="syntax-keyword">if</span> t_max &lt; 0.f <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;
    <span class="syntax-comment">// Check raycast range.</span>
    <span class="syntax-keyword">if</span> ray.t_min &gt; t_min || t_min &gt; ray.t_max <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;

    <span class="syntax-keyword">if</span> hit <span class="syntax-keyword">{</span>
        hit.t = t_min;
        <span class="syntax-comment">// Get hit normal.</span>
        <span class="syntax-keyword">if</span> t_min == t_min_x <span class="syntax-keyword">{</span>
            hit.n = <span class="syntax-keyword">if</span> t_left &lt; t_right <span class="syntax-keyword">then</span> v3.<span class="syntax-keyword">{</span> x = -1.f <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> .<span class="syntax-keyword">{</span> x = 1.f <span class="syntax-keyword">}</span>;
        <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">if</span> t_min == t_min_y <span class="syntax-keyword">{</span>
            hit.n = <span class="syntax-keyword">if</span> t_bottom &lt; t_top <span class="syntax-keyword">then</span> v3.<span class="syntax-keyword">{</span> y = -1.f <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> .<span class="syntax-keyword">{</span> y = 1.f <span class="syntax-keyword">}</span>;
        <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> <span class="syntax-keyword">{</span>
            hit.n = <span class="syntax-keyword">if</span> t_front &lt; t_back <span class="syntax-keyword">then</span> v3.<span class="syntax-keyword">{</span> z = -1.f <span class="syntax-keyword">}</span> <span class="syntax-keyword">else</span> .<span class="syntax-keyword">{</span> z = 1.f <span class="syntax-keyword">}</span>;
        <span class="syntax-keyword">}</span>
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> true;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Ray-vs-Triangle">Ray vs Triangle</h2>
<p>A fundamental part of the raycast against the triangle mesh is testing the raycast against a single triangle. A triangle is defined simply by 3 vectors (points) in 3D space. There are actually more methods to do this check. Probably the simplest one is checking whether our raycast hits a plane defined by the triangle, and if so, whether the intersection point with that plane lies inside the triangle's area using barycentric coordinates.</p>
<p>We'll use another approach, the <em>Möller–Trumbore</em> algorithm, which is a bit more compact and gives the desired result right away.</p>
<p>In this case, I had quite a hard time understanding what was going on. All the following depends on what I remember from high school, and that's really not that much. What is even worse is that these concepts are usually taught as a bunch of memorized rules without any deep knowledge of what's going on. Thus, I forget them very quickly without any chance to refresh them using pure logic. I'll try to describe it as best I can, step by step.</p>
<p>First, we need a mathematical way to describe the input triangle and all points it might contain. Each triangle in a triangle mesh is usually stored as a set of 3 vertices. So let's start there. We have a triangle defined by 3 points A, B, and C. Before we begin, let's take a look at some simple cases first. Say we have a 2D triangle formed by basis axis vectors of size one and a hypotenuse connecting them:</p>
<p><img src="raycasting/triangle.svg" alt=""></p>
<p>As you can see, <code>B-A</code> forms the edge vector <code>E1</code>, and <code>C-A=E2</code>. In this case, <code>E1</code> is the same as the <code>x</code> axis, and its length is 1, and <code>E2</code> is the same as the <code>y</code> axis, and its length is also 1. So we can right away tell that <code>E1=[1, 0]</code> and <code>E2=[0, 1]</code>.</p>
<p>Now, to get to the point <code>Q</code>, we need to travel some friction of <code>E1</code>, and add some friction of <code>E2</code>. Let's call these frictions <code>u</code> and <code>v</code>.</p>
<p><img src="raycasting/triangle3.svg" alt=""></p>
<p>So we have the following:</p>
<p><img src="raycasting/triangle2.svg" alt=""></p>
<p>You might ask why we need such a complicated thing for something so obvious. Well, now we have exposed some general properties we can apply to any triangle. All we need is a pair of edge vectors and <code>uv</code> values. There is only one last thing: our triangle might not have point <code>A</code> at the origin, so we need to take this into account by offsetting the whole system by the <code>A</code> vector. So, finally, any point <code>P</code> inside a triangle is defined as follows:</p>
<p><img src="raycasting/triangle4.svg" alt=""></p>
<p>We can write the same thing in a matrix form:</p>
<p><img src="raycasting/triangle5.svg" alt=""></p>
<p>Another key observation we might have here is that to form a triangle, the sum of our coefficients <code>u</code> and <code>v</code> cannot exceed one. If you look at the previous plot we used, the <code>BC</code> line can be defined as <code>u=1-v</code>, thus in the context of our triangle, we have <code>u+v&lt;=1</code>.</p>
<p>Since we have a general equation describing a triangle, we can again inject the raycast definition:</p>
<p><img src="raycasting/triangle6.svg" alt=""></p>
<p>Now we deal with the 3x3 linear system.</p>
<p>Let's call our first matrix containing all coefficients <code>M</code>, then the <code>[u, v, t]</code> vector <code>x</code>, and the right side vector <code>v</code>. To solve this linear system for <code>x</code>, we usually multiply both sides by the inverse matrix of <code>M</code>.</p>
<p><img src="raycasting/triangle7.svg" alt=""></p>
<p>Note that <code>M</code> inverse multiplied by <code>M</code> does nothing, so we can remove both from the left side.</p>
<p>The problem is that calculating the inverse matrix is a computationally heavy operation, and doing it for every triangle would be wasteful and slow for more complex meshes. Luckily, we can use a shortcut in the form of the <em>Möller–Trumbore</em> algorithm.</p>
<h2 id="Ray-vs-Triangle-Mesh">Ray vs Triangle Mesh</h2>
<h2 id="Ray-Transformation">Ray Transformation</h2>
<h2 id="Conclusion">Conclusion</h2>
<h2 id="Sources">Sources</h2>
<ul>
<li><a href="https://www.youtube.com/live/fjOdtSu4Lm4?si=qgWHYcV_Co30lcU0">Math for Game Devs [2022, part 1] • Numbers, Vectors & Dot Product - Freya Holmér</a></li>
<li><a href="https://youtu.be/kYB8IZa5AuE?si=0AB_p4z7D6EJOrlU">Linear transformations and matrices - 3Blue1Brown</a></li>
<li><a href="https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf">Fast Minimum Storage RayTriangle Intersection</a></li>
</ul>
</div>
<div class="column" id="column3">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="#Cast-the-Ray">Cast the Ray</a></li>
<ul>
<li><a href="#What-is-raycast?">What is raycast?</a></li>
<li><a href="#Hit-Point">Hit Point</a></li>
<li><a href="#Ray-vs-Plane">Ray vs Plane</a></li>
<li><a href="#Ray-vs-Sphere">Ray vs Sphere</a></li>
<li><a href="#Ray-vs-Axis-Aligned-Bounding-Box">Ray vs Axis Aligned Bounding Box</a></li>
<li><a href="#Ray-vs-Triangle">Ray vs Triangle</a></li>
<li><a href="#Ray-vs-Triangle-Mesh">Ray vs Triangle Mesh</a></li>
<li><a href="#Ray-Transformation">Ray Transformation</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#Sources">Sources</a></li>
</ul>
</ul>
</div>
</div>
</body>
</html>
