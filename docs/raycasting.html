<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<div class="container">
<div class="column" id="column1">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="index.html">Home</a></li>
<li id="menu-top-level-item"><a href="raycasting.html">Cast the Ray</a></li>
<li id="menu-top-level-item"><a href="struct-metadata.html">Struct Metadata</a></li>
</ul>
</div>
<div class="column" id="column2">
<h1 id="Cast-the-Ray">Cast the Ray</h1>
<p>While working on my game, I encountered a common issue. How to select entities in the game world by clicking on them, and how to handle entity collisions. When you use any modern game engine, those things would most likely be fully covered by a physics engine or simply part of the engine API. But I don’t have such a thing.</p>
<p>Originally, I didn’t want to spend too much time on this; there is a lot more to cover while creating a game from scratch. The laziest approach is relying on AI, just letting it implement all collision-related procedures, and copy-paste them with some possible adjustments. This kinda works until it doesn’t, and you find yourself staring at code you actually don’t understand. So I decided to step back and try to dedicate more time to this.</p>
<p>The usual solution would be to cast a ray from the player/camera position into the world and use the hit information to select an entity or handle collisions, if any.</p>
<p>In this blog post, I’ll try to explain in detail how to implement simple raycasting, focusing on the practical side, and do a little bit of math in a way even I’m able to understand (I’m not really into math).</p>
<h2 id="What-is-raycast?">What is raycast?</h2>
<p>You can think about it as a laser beam pointing from a point in the game world in some direction, and we somehow want to detect if this beam hits something in the world, and get some information about the hit point. So let's define our raycast as origin point <code>O</code> and normalized direction vector <code>D</code>.</p>
<p><img src="raycasting/raycast.svg" alt=""></p>
<p>Such a definition of raycast on its own is not enough. We also need to control where we are on this oriented line. Since the direction vector is normalized, we can just multiply it by a scalar, usually called <code>t</code> to control how far from the origin we are. Note that when the direction vector is normalized, <code>t</code> is actually in world units. So to get, for example, point <code>P</code> two units far from the origin in the direction <code>D</code> we do <code>P=O+2D</code>.</p>
<p>This brings us to the general definition of our raycast:</p>
<p><img src="raycasting/formula.svg" alt=""></p>
<p>From a practical side, it's good to define some bounds for the <code>t</code> value. We probably don't want it to be negative, and we usually don't want to include hits too far from the origin. To have full control over these properties, we can define <code>t_min</code> and <code>t_max</code> values.</p>
<p>So the full definition of the raycast in code looks like this:</p>

<pre><code>Ray :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    origin: v3;
    direction: v3;
    t_min: f32;
    t_max: f32;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Hit-Point">Hit Point</h2>
<p>By hit point, we mean the exact intersection point of our raycast and the object in the scene. In other words, we're trying to find one point lying on the raycast and geometry at the same time. Based on the raycast definition, we're looking for <code>t</code> value of such a point.</p>
<p>To store collected information about the hit point, I use the following structure:</p>

<pre><code>Hit :: <span class="syntax-keyword">struct</span> <span class="syntax-keyword">{</span>
    id: u32;
    t:  f32;
    n:  v3;
<span class="syntax-keyword">}</span>
</code></pre>
<p>Where <code>id</code> is a unique identifier of the hit object, <code>t</code> value and hit surface normal <code>n</code>. You can include any other information needed.</p>
<p>As you can imagine, calculating the intersection of our ray with a full model triangle geometry might be too complex to start with, so let's take a look at the simplest case possible first.</p>
<h2 id="Ray-vs-Plane">Ray vs Plane</h2>
<p>Probably the simplest case we can implement is checking if our raycast intersects a plane. Crucial construct used in the following calculations is <em>dot product</em>, I'll not go into details explaining it here, you can watch <a href="https://www.youtube.com/live/fjOdtSu4Lm4?si=qgWHYcV_Co30lcU0">video</a> from Freya Holmér containing a very detailed explanation.</p>
<p>Let's just highlight some algebra-like properties of the dot product (<code>⋅</code>):</p>
<ul>
<li>Commutative: <code>A⋅B=B⋅A</code></li>
<li>Distributive: <code>A⋅(B+C)=A⋅B+A⋅C</code></li>
<li>Scalar multiplication: <code>(sA)⋅B=s(A⋅B)</code></li>
</ul>
<p>Our plane will be defined by the origin point in space <code>P0</code> and a normal vector <code>N</code> like this:</p>
<p><img src="raycasting/plane.svg" alt=""></p>
<p>So in mathematical terms, where <code>P</code> is any point lying on the plane, we can write this:</p>
<p><img src="raycasting/plane-formula.svg" alt=""></p>
<p>Note that the dot product is 0 in case its input vectors are perpendicular.</p>
<p>When we're looking for the intersection point, we can just inject our previous raycast definition into the plane definition and solve it for <code>t</code>. Note that I use capital letters for vectors and small letters for scalars (float numbers) here.</p>
<p><img src="raycasting/inject-plane-formula.svg" alt=""></p>
<p>Now we can calculate the value of <code>t</code>, telling us how far from the raycast origin the ray intersects the plane. Thus, to calculate the hit point position, we can use the raycast definition with our <code>t</code> value.</p>
<p><img src="raycasting/formula.svg" alt=""></p>
<p>As you may have noticed, we divide by <code>N⋅D</code>, but the denominator cannot be 0. As already mentioned, the dot product is zero when the input vectors are perpendicular; this means our raycast is perfectly parallel to our plane and thus never hits it. We have to check this explicitly in the code.</p>
<p>The final ray vs plane procedure might be implemented like this:</p>

<pre><code>ray_vs_plane :: <span class="syntax-keyword">fn</span> (ray: Ray, p0: v3, n: v3, hit: *Hit) bool <span class="syntax-keyword">{</span>
    o :: ray.origin;
    d :: ray.direction;

    denom :: dot(d, n);
    <span class="syntax-keyword">if</span> math.compare(denom, 0.f, EPS) <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;

    t :: dot(n, sub(p0, o)) / denom;
    <span class="syntax-keyword">if</span> t &gt;= ray.t_min && t &lt;= ray.t_max <span class="syntax-keyword">{</span>
        hit.t = t;
        hit.n = n;
        <span class="syntax-keyword">return</span> true;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> false;
<span class="syntax-keyword">}</span>
</code></pre>
<h2 id="Ray-vs-Sphere">Ray vs Sphere</h2>
<p>Similarly, we can find the raycast collision point with a sphere. The whole equation is a bit more complex; however, it applies the same principles. Our sphere is defined as a centre point <code>P0</code> and a radius <code>r</code>. For any point <code>P</code> we can define a sphere as follows:</p>
<p><img src="raycasting/sphere.svg" alt=""></p>
<p>Note that <code>||</code> here represents <em>vector magnitude</em>. There is also one simple trick I didn't know, we can represent the squared magnitude of any vector as <em>dot product</em> with itself. Thus, we can do the following to make our computation a bit "easier".</p>
<p><img src="raycasting/sphere2.svg" alt=""></p>
<p>Now we can replace point <code>P</code> with the raycast formula:</p>
<p><img src="raycasting/sphere3.svg" alt=""></p>
<p>In the next steps, we solve this equation for <code>t</code>. Since it's easy for me to mess up, I do some substitutions here and there to reduce the risk (<code>L</code> and <code>M</code> variables).</p>
<p><img src="raycasting/sphere4.svg" alt=""></p>
<p>Finally, some rearrangement:</p>
<p><img src="raycasting/sphere5.svg" alt=""></p>
<p>At this point, it's getting quite obvious that we're dealing with a quadratic equation:</p>
<p><img src="raycasting/sphere6.svg" alt=""></p>
<p>We can write down all coefficients:</p>
<p><img src="raycasting/sphere7.svg" alt=""></p>
<p>To solve <code>t</code> we can use the quadratic formula (google it):</p>
<p><img src="raycasting/sphere8.svg" alt=""></p>
<p>Let's take a look at the <em>determinant</em> first:</p>
<p><img src="raycasting/sphere9.svg" alt=""></p>
<p>In case the <em>determinant</em> is negative, we cannot calculate its square root. Meaning the raycast completely missed the sphere.</p>
<p>In case the <em>determinant</em> value is zero, the quadratic equation has only one solution, meaning the raycast just touched the sphere at a single point.</p>
<p>Otherwise, we have to pick <code>t</code> greater than <code>t_min</code> and one closer to the raycast origin.</p>
<p><img src="raycasting/sphere10.svg" alt=""></p>
<p>The final ray vs plane procedure might be implemented like this:</p>

<pre><code>ray_vs_sphere :: <span class="syntax-keyword">fn</span> (ray: Ray, sphere_center: v3, sphere_radius: f32, hit: *Hit) bool <span class="syntax-keyword">{</span>
    o  :: ray.origin;
    d  :: ray.direction;
    p0 :: sphere_center;
    r  :: sphere_radius;

    op :: sub(o, p0);
    a :: dot(d, d);
    b :: 2.f*dot(d, op);
    c :: dot(op, op)-r*r;

    det :: b*b-4.f*a*c;
    <span class="syntax-comment">// Quadratic equation does not have any solution, ray misses the sphere.</span>
    <span class="syntax-keyword">if</span> det &lt; 0.f <span class="syntax-keyword">then</span> <span class="syntax-keyword">return</span> false;

    a2 :: 2.f*a;
    detsqrt :: math.sqrt(det);
    t1 :: (-b + detsqrt)/a2;
    t2 :: (-b - detsqrt)/a2;

    <span class="syntax-comment">// Possible cases:</span>
    <span class="syntax-comment">// t1 &lt; t_min && t2 &lt; t_min: Both hits are behind the raycast origin.</span>
    <span class="syntax-comment">// t1 &lt; t_min && t2 &gt; t_min: We're inside the sphere.</span>
    <span class="syntax-comment">// t1 &gt; t_min && t2 &gt; t_min: We're hitting the sphere and we should pick closest point.</span>

    t := t1;
    <span class="syntax-keyword">if</span> t &lt; ray.t_min <span class="syntax-keyword">{</span>
        t = t2;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">if</span> t &gt;= ray.t_min && t &lt;= ray.t_max <span class="syntax-keyword">{</span>
        p :: add(o, mul(d, t));

        hit.t = t;
        hit.n = div(sub(p, p0), r);
        <span class="syntax-keyword">return</span> true;
    <span class="syntax-keyword">}</span>

    <span class="syntax-keyword">return</span> false;
<span class="syntax-keyword">}</span>
</code></pre>
</div>
<div class="column" id="column3">
<ul id="menu-top-level">
<li id="menu-top-level-item"><a href="#Cast-the-Ray">Cast the Ray</a></li>
<ul>
<li><a href="#What-is-raycast?">What is raycast?</a></li>
<li><a href="#Hit-Point">Hit Point</a></li>
<li><a href="#Ray-vs-Plane">Ray vs Plane</a></li>
<li><a href="#Ray-vs-Sphere">Ray vs Sphere</a></li>
</ul>
</ul>
</div>
</div>
</body>
</html>
